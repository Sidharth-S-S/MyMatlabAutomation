%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% @brief
% Automatic generation of Simulink bus with named signals.
% The names of the signals are stored in an external text file, where they
% can easily edited.
% In the model a demux block, a bus block and a constant block is
% generated. The demux and the bus get the same number of outputs and
% inputs as sepcified in the external file and the names from there are
% assigned.
%
% Created with Matlab 2018b
%
% @author        Gerd Steinhilber (ED/ESY3)
% @version       1.0
% @copyright     (c)2021 Robert Bosch GmbH, ED/ESY 
% @license{none}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Used example as starting point from:
% https://de.mathworks.com/matlabcentral/answers/269605-naming-of-bus-elements-using-a-cell-array-of-names
%
%% Create a bus object in the workspace and save it
%
[signalNames,signalVals] = createSignalVector('busSignalNames.txt','Source',1,'Net',1,20);
signalVals = signalVals';
%
signalNamesTmp1 = signalNames;

% Create the Simulink model
new_system('myModel');
open_system('myModel'); % Open model visibly
set_param('myModel','Lock','off'); % Unlock it
% Create the elements we need here
yblockMin = 35;
yblockMax = yblockMin+50*length(signalNames);
%
blockWidth = 5;
xDemuxMin = 150;
xDemuxMax = xDemuxMin+blockWidth;
yDemuxMin = yblockMin;
yDemuxMax = yblockMax;
%
xBusMin = xDemuxMax + 200; 
xBusMax = xBusMin+blockWidth;
%
add_block('built-in/Demux','myModel/myDemux', 'DisplayOption','bar','Position',[xDemuxMin yDemuxMin xDemuxMax yDemuxMax]);
add_block('built-in/BusCreator','myModel/myBusCreator', 'Position',[xBusMin yblockMin xBusMax yblockMax])
%
%% Update the Simulink model
%
% Set the number of signals
%
set_param('myModel/myDemux', 'Outputs', num2str(numel(signalNamesTmp1)));
set_param('myModel/myBusCreator', 'Inputs', num2str(numel(signalNamesTmp1)));
% Get handles to ports which shall be connected
inPorts = get_param('myModel/myBusCreator', 'PortHandles');
outPorts = get_param('myModel/myDemux', 'PortHandles');
for i = 1:numel(outPorts) % Assign names to outputs of myDemux
    set(outPorts.Outport(i), 'SignalName', signalNamesTmp1{i});
end
% Specify to use the previously saved bus definition
set_param('myModel/myBusCreator', 'OutDataTypeStr', 'Inherit: auto');
% Connect the demux and bus creator blocks and assign the names
for i=1:length(signalNamesTmp1)
    add_line('myModel', outPorts.Outport(i), inPorts.Inport(i));
    set_param(outPorts.Outport(i), 'Name', signalNamesTmp1{i});
end
%
% add a constant block for initialization of the bus signal
% --> It is a constant block with a vector as value
%
if (length(signalVals)>1)
    strHelp = '[';
    for ii = 1:length(signalVals)-1
        strHelp = [strHelp,num2str(signalVals(ii)),';']; %#ok<AGROW>
    end
    strHelp = [strHelp,num2str(signalVals(end)),']'];
end
%
blockWidth = 50;
blockHeight = 30;
xConstantStart = xDemuxMin-blockWidth - 200;
xConstantEnd = xConstantStart+blockWidth;
yConstantStart = yDemuxMin + 0.5*(yDemuxMax-yDemuxMin) - 0.5*blockHeight;
yConstantEnd = yConstantStart+blockHeight;
%
add_block('built-in/Constant', [gcs,'/myConstant'],...
    'Position', [xConstantStart yConstantStart xConstantEnd yConstantEnd],...
    'Value',num2str(strHelp));
%
inPorts = get_param('myModel/myDemux', 'PortHandles');
outPorts = get_param('myModel/myConstant', 'PortHandles');
ii = 1;
add_line('myModel', outPorts.Outport(ii), inPorts.Inport(ii));
%
set_param(gcs, 'ZoomFactor','FitSystem');



function [signalName,signalVal] = createSignalVector(filename,expression1,expression1Val,expression2,expression2Val,standardVal)
%IMPORTFILE Import numeric data from a text file as a matrix.
%   MOR = IMPORTFILE(FILENAME) Reads data from text file FILENAME for the
%   default selection.
%
%   MOR = IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads data from rows
%   STARTROW through ENDROW of text file FILENAME.
%
% Example:
%   mor = importfile('mor.B.names', 1, 23);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2020/02/24 15:10:21

%% Initialize variables.
delimiter = {''};
startRow = 1;
endRow = inf;
% if nargin<=3
%     startRow = 1;
%     endRow = inf;
%     Tinit= Tinit;
% end

%% Format for each line of text:
%   column1: text (%s)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(1)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
for block=2:length(startRow)
    frewind(fileID);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(block)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
    dataArray{1} = [dataArray{1};dataArrayBlock{1}];
end

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Create output variable
bNames=dataArray{1,1};
% signalName = bNames;
for ii = 1:length(bNames)
    signalName{ii} = char(bNames(ii)); %#ok<AGROW>
end

% expression1='Source';
startIndex1 = regexp(bNames,expression1);

signalVal = zeros(length(startIndex1),1);

% expression2='Net';
startIndex2 = regexp(bNames,expression2);

for ii =1:length(startIndex1)
    if startIndex1{ii,1}==1 
        signalVal(ii,1)=expression1Val;
    else
        if startIndex2{ii,1}==1
            signalVal(ii,1)=expression2Val;
        else
            signalVal(ii,1)=standardVal;
        end     
    end
end    

end
